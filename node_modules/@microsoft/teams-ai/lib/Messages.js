"use strict";
/**
 * @module teams-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Messages = exports.MessageInvokeNames = void 0;
const botbuilder_1 = require("botbuilder");
var MessageInvokeNames;
(function (MessageInvokeNames) {
    MessageInvokeNames["FETCH_INVOKE_NAME"] = "message/fetchTask";
})(MessageInvokeNames || (exports.MessageInvokeNames = MessageInvokeNames = {}));
/**
 * TaskModules class to enable fluent style registration of handlers related to Task Modules.
 * @template TState Type of the turn state object being persisted.
 */
class Messages {
    _app;
    /**
     * Creates a new instance of the TaskModules class.
     * @param {Application} app Top level application class to register handlers with.
     */
    constructor(app) {
        this._app = app;
    }
    /**
     * Registers a handler to process the initial fetch of the task module.
     * @remarks
     * Handlers should respond with either an initial TaskInfo object or a string containing
     * a message to display to the user.
     * @template TData Optional. Type of the data object being passed to the handler.
     * @param {(context: TurnContext, state: TState, data: TData) => Promise<TaskModuleTaskInfo | string>} handler - Function to call when the handler is triggered.
     * @param {TurnContext} handler.context - Context for the current turn of conversation with the user.
     * @param {TState} handler.state - Current state of the turn.
     * @param {TData} handler.data - Data object passed to the handler.
     * @returns {Application<TState>} The application for chaining purposes.
     */
    fetch(handler) {
        this._app.addRoute(async (context) => {
            return (context?.activity?.type === botbuilder_1.ActivityTypes.Invoke &&
                context?.activity?.name === MessageInvokeNames.FETCH_INVOKE_NAME);
        }, async (context, state) => {
            if (context?.activity?.channelId === botbuilder_1.Channels.Msteams) {
                const result = await handler(context, state, context.activity.value?.data ?? {});
                if (!context.turnState.get(botbuilder_1.INVOKE_RESPONSE_KEY)) {
                    // Format invoke response
                    let response;
                    if (typeof result == 'string') {
                        // Return message
                        response = {
                            task: {
                                type: 'message',
                                value: result
                            }
                        };
                    }
                    else {
                        // Return card
                        response = {
                            task: {
                                type: 'continue',
                                value: result
                            }
                        };
                    }
                    // Queue up invoke response
                    await context.sendActivity({
                        value: { body: response, status: 200 },
                        type: botbuilder_1.ActivityTypes.InvokeResponse
                    });
                }
            }
        }, true);
        return this._app;
    }
}
exports.Messages = Messages;
//# sourceMappingURL=Messages.js.map