"use strict";
/**
 * @module teams-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenAIModerator = void 0;
const internals_1 = require("../internals");
const AI_1 = require("../AI");
/**
 * A moderator that uses OpenAI's moderation API to review prompts and plans for safety.
 * @remarks
 * This moderation can be configure to review the input from the user, output from the model, or both.
 * @template TState Optional. Type of the applications turn state.
 */
class OpenAIModerator {
    _options;
    _client;
    /**
     * Creates a new instance of the OpenAI based moderator.
     * @param {OpenAIModeratorOptions} options Configuration options for the moderator.
     */
    constructor(options) {
        this._options = Object.assign({}, options);
        this._client = this.createClient(this._options);
    }
    /**
     * Reviews an incoming utterance for safety violations.
     * @param {TurnContext} context - Context for the current turn of conversation.
     * @param {TState} state - Application state for the current turn of conversation.
     * @returns {Promise<Plan | undefined>} An undefined value to approve the prompt or a new plan to redirect to if not approved.
     */
    async reviewInput(context, state) {
        switch (this._options.moderate) {
            case 'input':
            case 'both': {
                const input = state.temp.input ?? context.activity.text;
                const result = await this.createModeration(input, this._options.model);
                if (result) {
                    if (result.flagged) {
                        // Input flagged
                        return {
                            type: 'plan',
                            commands: [
                                {
                                    type: 'DO',
                                    action: AI_1.AI.FlaggedInputActionName,
                                    parameters: result
                                }
                            ]
                        };
                    }
                }
                else {
                    // Rate limited
                    return {
                        type: 'plan',
                        commands: [{ type: 'DO', action: AI_1.AI.HttpErrorActionName, parameters: {} }]
                    };
                }
                break;
            }
        }
        return undefined;
    }
    /**
     * Reviews the SAY commands generated by the planner for safety violations.
     * @param {TurnContext} context - Context for the current turn of conversation.
     * @param {TState} state - Application state for the current turn of conversation.
     * @param {Plan} plan - Plan generated by the planner.
     * @returns {Promise<Plan>} The plan to execute. Either the current plan passed in for review or a new plan.
     */
    async reviewOutput(context, state, plan) {
        switch (this._options.moderate) {
            case 'output':
            case 'both':
                for (let i = 0; i < plan.commands.length; i++) {
                    const cmd = plan.commands[i];
                    if (cmd.type == 'SAY') {
                        const output = cmd.response;
                        const result = await this.createModeration(output.content || '', this._options.model);
                        if (result) {
                            if (result.flagged) {
                                // Output flagged
                                return {
                                    type: 'plan',
                                    commands: [
                                        {
                                            type: 'DO',
                                            action: AI_1.AI.FlaggedOutputActionName,
                                            parameters: result
                                        }
                                    ]
                                };
                            }
                        }
                        else {
                            // Rate limited
                            return {
                                type: 'plan',
                                commands: [
                                    { type: 'DO', action: AI_1.AI.HttpErrorActionName, parameters: {} }
                                ]
                            };
                        }
                    }
                }
                break;
        }
        return plan;
    }
    get options() {
        return this._options;
    }
    createClient(options) {
        return new internals_1.OpenAIClient({
            apiKey: options.apiKey,
            organization: options.organization,
            endpoint: options.endpoint
        });
    }
    async createModeration(input, model) {
        const response = (await this._client.createModeration({
            input,
            model
        }));
        if (response.data?.results && Array.isArray(response.data.results) && response.data.results.length > 0) {
            return response.data.results[0];
        }
        else {
            return undefined;
        }
    }
}
exports.OpenAIModerator = OpenAIModerator;
//# sourceMappingURL=OpenAIModerator.js.map